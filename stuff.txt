class Process:
    """
    A simple class to store process attributes.
    For Priority scheduling, we store a default priority = 0 (can be overwritten).
    """
    def __init__(self, name, arrival_time, burst_time, priority=0):
        self.name = name
        self.arrival_time = arrival_time
        self.burst_time = burst_time
        self.remaining_time = burst_time  # for preemptive scheduling
        self.priority = priority          # used in priority scheduling

        self.waiting_time = 0
        self.turnaround_time = 0
        self.completion_time = 0

def FCFS(processes):
    """
    First-Come, First-Served Scheduling (Non-Preemptive).
    Assumes 'processes' is sorted by arrival_time, or we will sort it here.
    """
    # Sort by arrival time
    processes.sort(key=lambda p: p.arrival_time)

    current_time = 0
    for p in processes:
        if p.arrival_time > current_time:
            current_time = p.arrival_time
        # Process starts at current_time
        p.completion_time = current_time + p.burst_time
        p.turnaround_time = p.completion_time - p.arrival_time
        p.waiting_time = p.turnaround_time - p.burst_time

        current_time = p.completion_time

def SJF_non_preemptive(processes):
    """
    Shortest Job First (Non-Preemptive).
    Pick the next process with the shortest burst time among those that have arrived.
    """
    # Sort by arrival time first to break ties
    processes.sort(key=lambda p: p.arrival_time)

    completed = 0
    current_time = 0
    n = len(processes)
    visited = [False] * n

    while completed < n:
        # Find all processes that have arrived by 'current_time' and not completed yet
        idx = -1
        min_burst = float('inf')
        for i in range(n):
            if (processes[i].arrival_time <= current_time) and (not visited[i]):
                if processes[i].burst_time < min_burst:
                    min_burst = processes[i].burst_time
                    idx = i

        # If no process has arrived yet, jump time to the next arrival
        if idx == -1:
            # Find the process with the earliest arrival among those not visited
            next_proc = min([p for i, p in enumerate(processes) if not visited[i]], 
                            key=lambda x: x.arrival_time)
            current_time = next_proc.arrival_time
            continue

        # Schedule the chosen process
        visited[idx] = True
        p = processes[idx]
        start_time = current_time
        completion_time = start_time + p.burst_time

        p.completion_time = completion_time
        p.turnaround_time = p.completion_time - p.arrival_time
        p.waiting_time = p.turnaround_time - p.burst_time

        current_time = completion_time
        completed += 1

def SJF_preemptive(processes):
    """
    Shortest Remaining Time First (SRTF) - Preemptive version of SJF.
    We pick the process with the smallest remaining time among those that have arrived.
    """
    # Sort by arrival time to simplify
    processes.sort(key=lambda p: p.arrival_time)

    n = len(processes)
    completed = 0
    current_time = 0
    while completed < n:
        # Among the processes that have arrived, pick the one with smallest remaining_time
        ongoing_candidates = [p for p in processes if p.arrival_time <= current_time and p.remaining_time > 0]
        if not ongoing_candidates:
            # No process has arrived yet, so jump to the next arrival time
            current_time = min([p.arrival_time for p in processes if p.remaining_time > 0])
            continue

        # Pick the process with smallest remaining_time
        current_process = min(ongoing_candidates, key=lambda p: p.remaining_time)

        # Run it for 1 time unit (or you can run until an event changes)
        current_process.remaining_time -= 1
        current_time += 1

        # If the process finishes
        if current_process.remaining_time == 0:
            current_process.completion_time = current_time
            current_process.turnaround_time = current_process.completion_time - current_process.arrival_time
            current_process.waiting_time = current_process.turnaround_time - current_process.burst_time
            completed += 1

def Round_Robin(processes, quantum):
    """
    Round Robin Scheduling (Preemptive by definition).
    'quantum' is the time slice.
    """
    # Sort by arrival time to start in correct order
    processes.sort(key=lambda p: p.arrival_time)

    from collections import deque
    ready_queue = deque()
    n = len(processes)
    current_time = 0
    completed = 0
    i = 0  # index to track new arrivals

    while completed < n:
        # Enqueue newly arrived processes
        while i < n and processes[i].arrival_time <= current_time:
            ready_queue.append(processes[i])
            i += 1

        if not ready_queue:
            # If no process is in the queue, jump to next arriving process
            current_time = processes[i].arrival_time
            ready_queue.append(processes[i])
            i += 1

        # Take the first process in the queue
        current_process = ready_queue.popleft()

        # Run it for 'quantum' or until it finishes, whichever is first
        run_time = min(quantum, current_process.remaining_time)
        current_process.remaining_time -= run_time
        old_time = current_time
        current_time += run_time

        # Enqueue newly arrived processes during this run_time
        while i < n and processes[i].arrival_time <= current_time:
            ready_queue.append(processes[i])
            i += 1

        # If it finished
        if current_process.remaining_time == 0:
            current_process.completion_time = current_time
            current_process.turnaround_time = current_process.completion_time - current_process.arrival_time
            current_process.waiting_time = current_process.turnaround_time - current_process.burst_time
            completed += 1
        else:
            # Still has remaining time, put it back in the queue
            ready_queue.append(current_process)

def Priority_non_preemptive(processes):
    """
    Non-preemptive Priority Scheduling.
    Lower priority value = higher priority (by convention here).
    If you want the opposite, invert the comparison.
    """
    # Sort by arrival time first
    processes.sort(key=lambda p: p.arrival_time)

    n = len(processes)
    completed = 0
    current_time = 0
    visited = [False] * n

    while completed < n:
        # Among arrived processes, pick the highest priority (lowest priority value)
        idx = -1
        best_priority = float('inf')
        for i in range(n):
            if (processes[i].arrival_time <= current_time) and not visited[i]:
                if processes[i].priority < best_priority:
                    best_priority = processes[i].priority
                    idx = i

        if idx == -1:
            # No process has arrived yet
            # Jump to the next process's arrival time
            next_proc = min([p for i, p in enumerate(processes) if not visited[i]], 
                            key=lambda x: x.arrival_time)
            current_time = next_proc.arrival_time
            continue

        # Schedule the chosen process
        visited[idx] = True
        p = processes[idx]
        start_time = current_time
        finish_time = start_time + p.burst_time

        p.completion_time = finish_time
        p.turnaround_time = p.completion_time - p.arrival_time
        p.waiting_time = p.turnaround_time - p.burst_time

        current_time = finish_time
        completed += 1

def Priority_preemptive(processes):
    """
    Preemptive Priority Scheduling.
    Lower priority value = higher priority (by convention).
    """
    # Sort by arrival time
    processes.sort(key=lambda p: p.arrival_time)

    n = len(processes)
    current_time = 0
    completed = 0

    while completed < n:
        # Find all processes that have arrived and are not finished
        ready = [p for p in processes if p.arrival_time <= current_time and p.remaining_time > 0]
        if not ready:
            # Jump to next arrival if none are ready
            current_time = min([p.arrival_time for p in processes if p.remaining_time > 0])
            continue

        # Pick the process with highest priority (lowest priority value)
        current_process = min(ready, key=lambda p: p.priority)

        # Run it for 1 unit (or until an event changes)
        current_process.remaining_time -= 1
        current_time += 1

        # If the process finishes
        if current_process.remaining_time == 0:
            current_process.completion_time = current_time
            current_process.turnaround_time = current_process.completion_time - current_process.arrival_time
            current_process.waiting_time = current_process.turnaround_time - current_process.burst_time
            completed += 1


# ------------------------------------------------------------------
# EXAMPLE MAIN (for demonstration; you can adapt/remove as needed)
# ------------------------------------------------------------------
if __name__ == "__main__":
    # Example usage reading from user input:
    processes = []
    n = int(input("Enter the number of processes: "))
    scheduling_choice = input(
        "Choose an algorithm:\n"
        "1) FCFS\n"
        "2) SJF (Non-Preemptive)\n"
        "3) SJF (Preemptive)\n"
        "4) Round Robin\n"
        "5) Priority (Non-Preemptive)\n"
        "6) Priority (Preemptive)\n"
        "Enter your choice (1-6): "
    )

    # For priority scheduling, you might ask for priority as well
    # For Round Robin, you will ask for quantum

    if scheduling_choice == '5' or scheduling_choice == '6':
        # Priority-based
        for i in range(n):
            name = input(f"Enter the name of Process {i+1}: ")
            arrival_time = int(input("Enter the arrival time: "))
            burst_time = int(input("Enter the burst time: "))
            priority = int(input("Enter the priority (lower = higher priority): "))
            processes.append(Process(name, arrival_time, burst_time, priority))
    else:
        # Non-priority
        for i in range(n):
            name = input(f"Enter the name of Process {i+1}: ")
            arrival_time = int(input("Enter the arrival time: "))
            burst_time = int(input("Enter the burst time: "))
            processes.append(Process(name, arrival_time, burst_time))

    # Show initial order
    print("\nInitial list of processes (unsorted):")
    for p in processes:
        print(f"Process: {p.name}, Arrival: {p.arrival_time}, Burst: {p.burst_time}, Priority: {p.priority}")

    # Run the chosen scheduling
    if scheduling_choice == '1':
        FCFS(processes)
    elif scheduling_choice == '2':
        SJF_non_preemptive(processes)
    elif scheduling_choice == '3':
        SJF_preemptive(processes)
    elif scheduling_choice == '4':
        quantum = int(input("Enter the time quantum for Round Robin: "))
        Round_Robin(processes, quantum)
    elif scheduling_choice == '5':
        Priority_non_preemptive(processes)
    elif scheduling_choice == '6':
        Priority_preemptive(processes)
    else:
        print("Invalid choice!")
        exit()

    # Display results
    print("\n=== Scheduling Results ===")
    print("Process | Arrival | Burst | Priority | Completion | Waiting | Turnaround")
    for p in processes:
        print(f"{p.name:7s} | {p.arrival_time:7d} | {p.burst_time:5d} | {p.priority:8d} | "
              f"{p.completion_time:10d} | {p.waiting_time:7d} | {p.turnaround_time:10d}")
